<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>AMS by aozturk</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">AMS</h1>
      <h2 class="project-tagline">Asynchronous Messaging Service Framework</h2>
      <a href="https://github.com/aozturk/AMS" class="btn">View on GitHub</a>
      <a href="https://github.com/aozturk/AMS/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/aozturk/AMS/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="asynchronous-messaging-service-ams" class="anchor" href="#asynchronous-messaging-service-ams" aria-hidden="true"><span class="octicon octicon-link"></span></a>Asynchronous Messaging Service (AMS)</h1>

<h3>
<a id="pubsub-framework-for-highly-scalable-distributed-systems" class="anchor" href="#pubsub-framework-for-highly-scalable-distributed-systems" aria-hidden="true"><span class="octicon octicon-link"></span></a>PubSub Framework for Highly Scalable Distributed Systems</h3>

<h2>
<a id="features" class="anchor" href="#features" aria-hidden="true"><span class="octicon octicon-link"></span></a>Features</h2>

<h4>
<a id="asynchronous" class="anchor" href="#asynchronous" aria-hidden="true"><span class="octicon octicon-link"></span></a>Asynchronous</h4>

<p>Asynchronous message passing systems deliver a message from sender to receiver, without waiting for the receiver to be ready. The advantage of asynchronous communication is that the sender and receiver can overlap their computation because they do not wait for each other.</p>

<p>The reactor used in AMS handles requests delivered concurrently by multiple event resources. Mesage dispatcher handles registering and unregistering of application-defined message handlers, and dispatches messages from the demultiplexer to the associated handlers. Event demultiplexer uses an event loop to block on all resources.</p>

<h4>
<a id="loosely-coupled" class="anchor" href="#loosely-coupled" aria-hidden="true"><span class="octicon octicon-link"></span></a>Loosely Coupled</h4>

<p>In a data system based on AMS, any module may be introduced into or removed from the system at any time without inhibiting the ability of any other module to continue sending and receiving messages. The system’s modules have no inter-dependency to become or stay operational. </p>

<p>By publish–subscribe pattern used in AMS, senders of messages called publishers do not program the messages to be sent directly to specific receivers. Instead, published messages are characterized into classes, without knowledge of subscribers. Similarly, subscribers express interest in one or more classes, and only receive messages that are of interest, without knowledge of publishers.</p>

<h4>
<a id="fault-tolerant" class="anchor" href="#fault-tolerant" aria-hidden="true"><span class="octicon octicon-link"></span></a>Fault-tolerant</h4>

<p>AMS-based systems are highly robust, lacking any single point of failure and tolerant of unplanned module termination. </p>

<h4>
<a id="dynamic-discovery" class="anchor" href="#dynamic-discovery" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dynamic Discovery</h4>

<p>AMS provides dynamic discovery of publishers and subscribers that makes your applications extensible. This means the application does not have to know or configure the endpoints for communications because they are automatically discovered. AMS will also discover the type of data being published. </p>

<p>If multicast is not supported for target environment or dynamic discovery is not preferred, AMS also uses customized config.xml file during initialization to determine peers in the network topology. </p>

<h4>
<a id="fast" class="anchor" href="#fast" aria-hidden="true"><span class="octicon octicon-link"></span></a>Fast</h4>

<p>Communication within an AMS-based system is rapid and efficient:</p>

<ul>
<li>Messages are exchanged directly between modules rather than through any central
message dispatching nexus (i.e. brokers).</li>
<li>Messages are automatically conveyed using the most suitable underlying transport service (TCP/IP) to which the sending and receiving modules both have access. </li>
</ul>

<h4>
<a id="scalable" class="anchor" href="#scalable" aria-hidden="true"><span class="octicon octicon-link"></span></a>Scalable</h4>

<p>Finally, AMS provides high scalability; hundreds or thousands of cooperating modules have no significant impact on application performance.</p>

<h2>
<a id="c-api" class="anchor" href="#c-api" aria-hidden="true"><span class="octicon octicon-link"></span></a>C++ API</h2>

<p>Creates or just returns a singleton AMS service instance</p>

<pre><code>static IService&amp; IService::instance();
</code></pre>

<p>Creates (or joins to) a messaging domain that is restricted for communication</p>

<pre><code>void IService::create_domain(std::string domainName, std::string appName);
</code></pre>

<p>Starts/stops the reactor for both the communication and the dynamic discovery</p>

<pre><code>void IService::reactor_start();
void IService::reactor_stop();
</code></pre>

<p>Creates a subscriber for T-typed messages</p>

<pre><code>template&lt;typename T&gt;
void IService::create_subscriber();
</code></pre>

<p>Subscribes a handler object for T-typed messages received</p>

<pre><code>template&lt;typename T&gt;
void IService::subscribe(IHandler&amp; handler);
</code></pre>

<p>Unsubscribes from receiving T-typed messages</p>

<pre><code>template&lt;typename T&gt;
void IService::unsubscribe();
</code></pre>

<p>Creates a publisher for T-typed messages</p>

<pre><code>template&lt;typename T&gt;
void IService::create_publisher();
</code></pre>

<p>Sends a message to all subscribers</p>

<pre><code>void IService::send_message(IMsgObj&amp; obj);
</code></pre>

<p>Registers a notifier for peer status updates within the domain</p>

<pre><code>void IService::register_discovery(IPeerNotification* notifier);
</code></pre>

<p>Returns the own host ip address</p>

<pre><code>std::string IService::get_host_ip() const;
</code></pre>

<p>Destroys the service singleton instance</p>

<pre><code>static void IService::destroy();
</code></pre>

<p>Returns the service global logger</p>

<pre><code>Poco::Logger&amp; IService::logger();  
</code></pre>

<p>Runs the service in debug mode for exhaustive logging</p>

<pre><code>void IService::debug_mode();
</code></pre>

<h2>
<a id="dependencies" class="anchor" href="#dependencies" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dependencies</h2>

<ul>
<li><a href="http://pocoproject.org/">Poco C++ 1.4.x</a></li>
<li><a href="http://zeromq.org/">ZeroMQ 3.2.x</a></li>
<li><a href="http://msgpack.org/">MessagePack 0.5.x</a></li>
</ul>

<h2>
<a id="example" class="anchor" href="#example" aria-hidden="true"><span class="octicon octicon-link"></span></a>Example</h2>

<p>Declaring our message class first. Classes can be composed from other classes.</p>

<pre><code>class TestMsg : public AMS::IMsgObj {
public:
    // gives unique id to each message
    TestMsg() : IMsgObj(/*msg id*/1) {
    }

    // can use primitive types and string
    std::string name;
    double value;
    // can use other class objects
    AdditionalInfo info;
    // can use vector and map containers
    std::vector&lt;int&gt; members;
    std::map&lt;int, int&gt; mappings;

    // allows serialization of only the selected members
    MSGPACK_DEFINE(name, value, info, members, mappings);
};

class AdditionalInfo {
public:
    std::string address;
    double offset;

    // adds only fields that will be serialized
    MSGPACK_DEFINE(address);
};
</code></pre>

<p>Publisher example</p>

<pre><code>void pub() {
    // creates or gets the singleton AMS service
    AMS::IService&amp; service = AMS::IService::instance();

    // enables exhaustive logging (i.e. message received/sent)
    service.debug_mode();
    // can use global logger of AMS service
    service.logger().information("publisher side running...");

    // should first create or join to a domain 
    // gives unique domain name and application name as parameters
    service.create_domain("ams_test", "Test_PUB");

    // creates a publisher for the associated message
    service.create_publisher&lt;TestMsg&gt;();

    // starts the reactor for communication
    service.reactor_start();

    for (int i=0; i&lt;100; ++i)
    {       
        // prepares a message to send
        TestMsg msg;
        msg.value = i;
        msg.name = "testing.";
        // sends the message to all subscribers
        service.send_message(msg);
    }
}
</code></pre>

<p>Subscriber example</p>

<pre><code>// defines a handler class for the message first
class TestMsgHandler : public AMS::IHandler {
public:
    virtual void handle(AMS::IMsgObj* baseMsg) {
        TestMsg* msg = dynamic_cast&lt;TestMsg*&gt;(baseMsg);
        if (msg != 0) {
            // process message here
        }
    }
};

void sub() {
    AMS::IService&amp; service = AMS::IService::instance();

    service.debug_mode();
    service.logger().information("subscriber side running...");

    // joins to the domain with unique application name
    service.create_domain("ams_test", "Test_SUB");

    // creates a subscriber for the associated message
    service.create_subscriber&lt;TestMsg&gt;();
    // attaches handler to the subscriber
    TestMsgHandler handler;
    service.subscribe&lt;TestMsg&gt;(handler);

    // starts the reactor for communication
    service.reactor_start();

    // wait enough here to receive messages sent by pusblisher
    // i.e. sleep
}
</code></pre>

<h2>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span class="octicon octicon-link"></span></a>License</h2>

<p>Licensed under <a href="LICENSE">the Apache 2.0 license</a>. </p>

<h2>
<a id="special-thanks" class="anchor" href="#special-thanks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Special Thanks</h2>

<p>I would like to thank <a href="http://hintjens.com/">Pieter Hintjens</a> for influences to start this project and thank <a href="http://www.jetbrains.com">JetBrains</a> for supporting the AMS project by offering open-source license of their <a href="http://www.jetbrains.com/objc/">AppCode IDE</a>.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/aozturk/AMS">AMS</a> is maintained by <a href="https://github.com/aozturk">aozturk</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

            <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-44999480-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

  </body>
</html>
