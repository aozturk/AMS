{"name":"AMS","tagline":"Asynchronous Messaging Service Framework","body":"Asynchronous Messaging Service (AMS)\r\n===\r\n\r\nFeatures\r\n--------\r\n\r\n#### Asynchronous\r\nAsynchronous message passing systems deliver a message from sender to receiver, without waiting for the receiver to be ready. The advantage of asynchronous communication is that the sender and receiver can overlap their computation because they do not wait for each other.\r\n\r\nThe reactor used in AMS handles requests delivered concurrently by multiple event resources. Mesage dispatcher handles registering and unregistering of application-defined message handlers, and dispatches messages from the demultiplexer to the associated handlers. Event demultiplexer uses an event loop to block on all resources.\r\n\r\n#### Loosely Coupled\r\nIn a data system based on AMS, any module may be introduced into or removed from the system at any time without inhibiting the ability of any other module to continue sending and receiving messages. The system’s modules have no inter-dependency to become or stay operational. \r\n\r\nBy publish–subscribe pattern used in AMS, senders of messages called publishers do not program the messages to be sent directly to specific receivers. Instead, published messages are characterized into classes, without knowledge of subscribers. Similarly, subscribers express interest in one or more classes, and only receive messages that are of interest, without knowledge of publishers.\r\n\r\n#### Fault-tolerant\r\nAMS-based systems are highly robust, lacking any single point of failure and tolerant of unplanned module termination. \r\n\r\n#### Dynamic Discovery\r\nAMS provides dynamic discovery of publishers and subscribers that makes your applications extensible. This means the application does not have to know or configure the endpoints for communications because they are automatically discovered. AMS will also discover the type of data being published. \r\n\r\nIf multicast is not supported for target environment or static discovery is the preferred method, AMS also uses custom config.xml file to determine peers in the network topology. \r\n\r\n#### Fast\r\nCommunication within an AMS-based system is rapid and efficient:\r\n* Messages are exchanged directly between modules rather than through any central\r\nmessage dispatching nexus (i.e. brokers).\r\n* Messages are automatically conveyed using the most suitable underlying transport service (TCP/IP) to which the sending and receiving modules both have access. \r\n\r\n#### Scalable\r\nFinally, AMS provides high scalability; hundreds or thousands of cooperating modules have no significant impact on application performance.\r\n\r\nAPI\r\n---\r\n\r\nCreate or just return a singleton IService instance\r\n\r\n    static IService& IService::instance();\r\n\r\nCreate (or joins to) a messaging domain that is restricted for communication\r\n\r\n    void IService::create_domain(std::string domainName, std::string appName);\r\n    \r\nStart/stop the reactor for both the communication and the dynamic discovery\r\n\r\n    void IService::reactor_start();\r\n    void IService::reactor_stop();\r\n\r\nCreate a subscriber for T-typed messages\r\n\r\n    template<typename T>\r\n    void IService::create_subscriber();\r\n    \r\nSubscribe a handler object for T-typed messages received\r\n\r\n    template<typename T>\r\n    void IService::subscribe(IHandler& handler);\r\n    \r\nUnsubscribe from receiving T-typed messages\r\n\r\n    template<typename T>\r\n    void IService::unsubscribe();\r\n\r\nCreate a publisher for T-typed messages\r\n\r\n    template<typename T>\r\n    void IService::create_publisher();\r\n\r\nSend a message to all subscribers\r\n\r\n    void IService::send_message(IMsgObj& obj);\r\n\r\nRegister a notifier for peer status updates within the domain\r\n\r\n    void IService::register_discovery(IPeerNotification* notifier);\r\n\r\nReturn the own host ip address\r\n\r\n    std::string IService::get_host_ip() const;\r\n    \r\nDestroy the service singleton instance\r\n\r\n    static void IService::destroy();\r\n    \r\nReturn the service global logger\r\n\r\n    Poco::Logger& IService::logger();  \r\n\r\nRun the service in debug mode for exhaustive logging\r\n\r\n    void IService::debug_mode();\r\n\r\nDependencies\r\n------------\r\n\r\n* Poco C++ 1.4.x\r\n* ZeroMQ 3.2.x\r\n* MessagePack 0.5.x\r\n\r\nExample\r\n-------\r\n\r\nDeclaring our message class first. Classes can be composed from other classes.\r\n\r\n    class TestMsg : public AMS::IMsgObj {\r\n    public:\r\n        // give unique id to each message\r\n        TestMsg() : IMsgObj(/*msg id*/1) {\r\n        }\r\n\r\n        // can use primitive types and string\r\n        std::string name;\r\n        double value;\r\n        // can use other class objects\r\n        AdditionalInfo info;\r\n        // can use vector and map containers\r\n        std::vector<int> members;\r\n        std::map<int, int> mappings;\r\n\r\n        // allow serialization of only the selected members\r\n        MSGPACK_DEFINE(name, value, info, members, mappings);\r\n    };\r\n\r\n    class AdditionalInfo {\r\n    public:\r\n        std::string address;\r\n        double offset;\r\n\r\n        // add only fields that will be serialized\r\n        MSGPACK_DEFINE(address);\r\n    };\r\n\r\nPublisher example\r\n    \r\n    void pub() {\r\n        // create or get the singleton AMS service\r\n        AMS::IService& service = AMS::IService::instance();\r\n        \r\n        // enable exhaustive logging (i.e. message received/sent)\r\n        service.debug_mode();\r\n        // can use global logger of AMS service\r\n        service.logger().information(\"publisher side running...\");\r\n\r\n        // should first create or join to a domain \r\n        // give unique domain name and application name as parameters\r\n        service.create_domain(\"ams_test\", \"Test_PUB\");\r\n\r\n        // creates a publisher for the associated message\r\n        service.create_publisher<TestMsg>();\r\n\r\n        // should start the reactor for communication\r\n        service.reactor_start();\r\n\r\n        for (int i=0; i<100; ++i)\r\n        {       \r\n            // prepare a message to send\r\n            TestMsg msg;\r\n            msg.value = i;\r\n            msg.name = \"testing.\";\r\n            service.send_message(msg);\r\n        }\r\n    }\r\n    \r\nSubscriber example\r\n\r\n    // define a handler class for the message first\r\n    class TestMsgHandler : public AMS::IHandler {\r\n    public:\r\n        virtual void handle(AMS::IMsgObj* baseMsg) {\r\n            TestMsg* msg = dynamic_cast<TestMsg*>(baseMsg);\r\n            if (msg != 0) {\r\n                // process message here\r\n            }\r\n        }\r\n    };\r\n\r\n    void sub() {\r\n        AMS::IService& service = AMS::IService::instance();\r\n\r\n        service.debug_mode();\r\n        service.logger().information(\"subscriber side running...\");\r\n \r\n        // joins to the domain with unique application name\r\n        service.create_domain(\"ams_test\", \"Test_SUB\");\r\n\r\n        // creates a subscriber for the associated message\r\n        service.create_subscriber<TestMsg>();\r\n        TestMsgHandler handler;\r\n        service.subscribe<TestMsg>(handler);\r\n\r\n        // should start the reactor for communication\r\n        service.reactor_start();\r\n        \r\n        // wait enough here to receive messages sent by pusblisher\r\n        // i.e. sleep() here\r\n    }\r\n\r\n\r\nLicense\r\n-------\r\n\r\nLicensed under [the Apache 2.0 license](LICENSE). \r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}